<!DOCTYPE html>
<html>
<head>
<title>PPT</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" href="./css/font-awesome.min.css">
<link rel="stylesheet" href="./css/animate.min.css">
<link rel="stylesheet" href="./css/slide.css"/>
<style>
body {
    background-color: #000;
}

.slide1 > h1 {
    color: #fff;
    text-align: center;
    margin-top: 300px;
    width: 100%;
    font-size: 50px;
}
.slide1 > p {
    color: #999;
    width: 65%;
    text-align: right;
}
.slide2 > img {
    max-width: 100%;
}

em {
    font-weight: bold;
}
</style>
</head>

<body>
<div class="slide" data-slide="0">
    <div class="slide1">
        <h1 class="hide" data-animate="zoomIn">Some Good Points</h1>
        <p class="hide" data-animate="fadeIn">by donaldyang</p>
    </div>
</div>

<div class="slide" data-slide="1">
    <div class="slide2">
        <h2>Main Points</h2>
        <ol>
            <li>任何前端开发遇到的问题都可以通过<em>封装</em>和<em>线下构建</em>来简化</li>
                <ul>
                    <li>封装：jQuery、Angular、Polymer</li>
                    <li>构建：Sass、Compass</li>
                    <li>封装 & 构建：React</li>
                </ul>
            <li>预定大于配置，良好的约定可以极大得简化开发上手难度和构建难度</li>
        </ol>
    </div>
</div>

<div class="slide" data-slide="2">
    <div class="slide2">
        <h2>Outline</h2>
        <ul>
            <li>Continuous的三种阶段</li>
            <li>从Wilon到Mockup Service</li>
            <li>Stream流行引发的变革</li>
            <li>约定式构建</li>
            <li>前端错误收集与快速定位</li>
            <li>AST应用</li>
        </ul>
    </div>
</div>

<div class="slide" data-slide="3">
    <div class="slide1">
        <h1 class="hide" data-animate="zoomIn">Continuous的三种阶段</h1>
    </div>
</div>

<div class="slide" data-slide="4">
    <div class="slide2">
        <h2>三种阶段</h2>
        <ol>
            <li>持续集成(Continuous integration)</li>
            <li>持续交付(Continuous delivery)</li>
            <li>持续部署(Continuous deployment)</li>
        </ol>
    </div>
</div>

<div class="slide" data-slide="5">
    <div class="slide2">
        <h2>持续集成(Continuous integration)</h2>
        <ul>
            <li>提早发现问题</li>
            <li>避免集成地狱(Integration Hell)，简单的说就是避免将许多人代码集成到一起成为一个发行版本时产生错误时无法定位，互相怀疑对方代码有问题的情况</li>
            <li>单元测试保证单元可靠，集成测试保证整体可靠，持续集成保证每次集成的粒度可控，出问题可查</li>
        </ul>
    </div>
</div>

<div class="slide" data-slide="6">
    <div class="slide2">
        <h2>持续交付(Continuous delivery)</h2>
        <p>将代码持续交付给QA团队，或用户，使得用户及早体验到产品，触发更短的迭代周期</p>
    </div>
</div>

<div class="slide" data-slide="7">
    <div class="slide2">
        <h2>持续部署(Continuous deployment)</h2>
        <p>更加极端的持续交付，当代码提交后，会自动触发自动化测试，当测试结束后自动部署，请见下图：</p>
        <img src="./img/cd.png">
    </div>
</div>

<div class="slide" data-slide="8">
    <div class="slide2">
        <h2>持续集成系统而非发布系统</h2>
        <ul>
            <li>实际上包括svn.server.com和jb.oa.com都已经不是简简单单的发布系统了，大量定制构成集成到发布构成中</li>
            <li>我们经常需要扩展发布系统本身来满足我们不断变化的需求，而实际上我们有更通用的方案——持续集成系统</li>
        </ul>
    </div>
</div>

<div class="slide" data-slide="9">
    <div class="slide1">
        <h1>Braindead CI DEMO</h1>
    </div>
</div>

<div class="slide" data-slide="10">
    <div class="slide1">
        <h1>从Wilon到Mockup Service</h1>
    </div>
</div>

<div class="slide" data-slide="11">
    <div class="slide2">
        <h2>Fillder & Wilon的问题</h2>
        <p>本质上来说Fillder是一个debug工具，满足调试需求，贯穿开发过程并不是一个好想法。</p>
        <ul>
            <li>不稳定，运行较慢，开启时间过久导致机子顿卡</li>
            <li>项目配置无法管理，导出导入很不人性化</li>
        </ul>
    </div>
</div>

<div class="slide" data-slide="12">
    <div class="slide2">
        <h2>Mockup service方案</h2>
        <p>在本地启动一个服务器，来代替Wilon的本地替换功能</p>
        <ul>
            <li>功能简单，运行稳定</li>
            <li>类似Grunt和Gulp，每个项目有单一的项目配置，跟随项目源码一起保存在代码托管服务中的那个，对于单一应项目开发者不需要多次配置</li>
        </ul>
    </div>
</div>

<div class="slide" data-slide="13">
    <div class="slide1">
        <h1>Panel中的Mockup Service演示</h1>
    </div>
</div>

<div class="slide" data-slide="14">
    <div class="slide1">
        <h1>Stream流行引发的变革</h1>
    </div>
</div>

<div class="slide" data-slide="15">
    <div class="slide2">
        <h2>Pipe</h2>
        <p>Unix中的重要编程理论，我们经常用 | 来使用管道。</p>
        <p>管道的魅力在于，任何人只要知道管道的规格，就能自行生产管道，并将各种连接起来(听起来很想水管工^ ^)</p>
        <p>NodeJS中Stream的引入起初是为了解决各种IO问题，但当发展到EventStream的时候，已经变成了任意数据的传递标准(即管道的规格)，满足这种标准我们就能自己生产自己的管子</p>
    </div>
</div>

<div class="slide" data-slide="16">
    <div class="slide2">
        <h2>Gulp</h2>
        <p>Gulp之前，NodeJS早已在Zlib和Crypto表现出其强大。但对于我来说Gulp是让我真正认识Stream的契机。</p>
        <p>Gulp约定了管子的标准，并且实际上我们可以看成，他是指定输入内容，经过管子，输出处理后内容。所以，如果我们把输入输出替换掉，中间的管子是可以复用的</p>
    </div>
</div>

<div class="slide" data-slide="17">
    <div class="slide2">
        <h2>middleware-pipe与inhale</h2>
        <p>middleware-pipe是一次Gulp管子复用的尝试，他可以将Gulp管子复用到Connect或Express框架中，继而让动态编译变得简单</p>
        <p>inhale是基于Connect和middleware-pipe的本地服务器框架，我们还在努力中，目前在“QQ查找——找课程”中有不错的尝试</p>
    </div>
</div>

<div class="slide" data-slide="18">
    <div class="slide1">
        <h1>QQ查找——找课程演示</h1>
    </div>
</div>

<script src="http://1.url.cn/jslib/jquery/1.9.1/jquery.min.js"></script>
<script src="./js/slide.js"></script>
<script>

    Slide
        .init();
</script>
</body>
</html>
